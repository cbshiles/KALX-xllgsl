// xll_ran_gaussian.cpp - Gaussian variates, density, cumulative distribution, and inverse
// http://www.gnu.org/software/gsl/manual/html_node/The-Multinomial-Distribution.html#The-Multinomial-Distribution
#include "../xll_rng.h"
#include "../xll_randist.h"
//#define EXCEL12
#include "xll/xll.h"

using namespace xll;

static AddInX xai_ran_multinomial(
	FunctionX(XLL_FPX, _T("?xll_ran_multinomial"), _T("GSL.RAN.MULTINOMIAL"))
	.Arg(XLL_HANDLEX, _T("rng"), _T("is a handle returned by GSL.RNG."))
	.Arg(XLL_WORDX,_T("N"),_T("is the sum of n"))
	.Arg(XLL_FPX, _T("p"), _T("is the probability of each event"))
	.Arg(XLL_FPX, _T("n"), _T("is the frequency of each event"))
	.Category(_T("GSL"))
	.FunctionHelp(_T("Return multinomial random deviates using a random number generator."))
	.Documentation(R_(
		This function returns a Gaussian random variate, with mean zero and standard deviation sigma. The probability distribution for Gaussian random variates is, 

		p[x] dx = {1 over sqrt{2 pi sigma^2}} exp [-x^2 / 2 sigma^2] dx

		for x in the range -infty to +infty. Use the transformation z = mu + x on the numbers returned by gsl_ran_gaussian to obtain a Gaussian distribution with mean mu. This function uses the Box-Muller algorithm which requires two calls to the random number generator r. 
	))
	);
void WINAPI xll_ran_multinomial(HANDLEX rng, WORD N, xfpx* p, xfpx* n)
{
#pragma XLLEXPORT
	doublex x;

	try {
		auto K = size(*p);
		ensure (K == size(*n));

		handle<gsl::rng> r(rng);

		std::vector<unsigned> n_(K);
		std::transform(begin(*n), end(*n), n_.begin(), [](double x) { return static_cast<unsigned>(x); });

		gsl_ran_multinomial(*r, K, N, p->array, n_.data());
	}
	catch (const std::exception& ex) {
		XLL_ERROR(ex.what());
	}

	//return x;
}

static AddInX xai_ran_multinomial_pdf(
	FunctionX(XLL_DOUBLEX, _T("?xll_ran_multinomial_pdf"), _T("GSL.DIST.MULTINOMIAL.PDF"))
	.Arg(XLL_HANDLEX, _T("k"), _T("is the number of the nomials."))
	.Arg(XLL_DOUBLEX, _T("p"), _T("is the probability of each event."))
	.Arg(XLL_DOUBLEX, _T("n"), _T("is the frequency of each event."))
	.Category(_T("GSL"))
	.FunctionHelp(_T("Return Multinomial probability density function."))
	.Documentation(_T(""))
	);
double WINAPI xll_ran_multinomial_pdf(size_t K, const double p[], const unsigned int n[])
{
#pragma XLLEXPORT
	/*if (sigma == 0)
		sigma = 1;*/

	return gsl_ran_multinomial_pdf(K, p,n);
}

//No CDF in the definition

/*static AddInX xai_cdf_multinomial_P(
	FunctionX(XLL_DOUBLEX, _T("?xll_cdf_multinomial_P"), _T("GSL.DIST.multinomial.CDF"))
	.Arg(XLL_HANDLEX, _T("k"), _T("is the number of the nomials."))
	.Arg(XLL_DOUBLEX, _T("p"), _T("is the probability of each event."))
	.Arg(XLL_DOUBLEX, _T("n"), _T("is nonegative interge."))
	.Category(_T("GSL"))
	.FunctionHelp(_T("Return Multinomial cumulative distribution function."))
	.Documentation(_T(""))
	);
double WINAPI xll_cdf_multinomial_P(size_t K, const double p[], const unsigned int n[])
{
#pragma XLLEXPORT
	/*if (sigma == 0)
		sigma = 1;
return gsl_cdf_multinomial_P( K, p, n);
}*/

/*static AddInX xai_cdf_multinomial_Pinv(
	FunctionX(XLL_DOUBLEX, _T("?xll_cdf_multinomial_Pinv"), _T("GSL.DIST.multinomial.INV"))
	.Arg(XLL_HANDLEX, _T("x"), _T("is the value at which to calculate the inverse cumulative distribution function."))
	.Arg(XLL_DOUBLEX, _T("sigma"), _T("is the standard deviation of the Multinomial. Default is 1"), 1.0)
	.Category(_T("GSL"))
	.FunctionHelp(_T("Return multinomial inverse cumulative distribution function."))
	.Documentation(_T(""))
	);
double WINAPI xll_cdf_multinomial_Pinv(size_t K, const double p[], const unsigned int n[])
{
#pragma XLLEXPORT
	/*if (sigma == 0)
		sigma = 1;

	return gsl_cdf_multinomial_Pinv(K, p, n);
}*/

XLL_TEST_BEGIN(xll_ran_multinomial)

double eps = 1e-4;

//pdf below is generated by Matlab
double pdf[] = { 0.0060, 0.0403, 0.1209, 0.2150, 0.2508, 0.2007, 0.1115, 0.0425, 0.0106, 0.0016, 0.0001 };
// http://www.wolframalpha.com/input/?i=Table%5BCDF%5BNormalDistribution%5B0%2C1%5D%2C+x%5D%2C%7Bx%2C+-2%2C+2%2C+.1%7D%5D
//double cdf[] = { 0.0227501, 0.0287166, 0.0359303, 0.0445655, 0.0547993, 0.0668072, 0.0807567, 0.0968005, 0.11507, 0.135666, 0.158655, 0.18406, 0.211855, 0.241964, 0.274253, 0.308538, 0.344578, 0.382089, 0.42074, 0.460172, 0.5, 0.539828, 0.57926, 0.617911, 0.655422, 0.691462, 0.725747, 0.758036, 0.788145, 0.81594, 0.841345, 0.864334, 0.88493, 0.9032, 0.919243, 0.933193, 0.945201, 0.955435, 0.96407, 0.971283, 0.97725 };

for (unsigned int i = 0; i < sizeof(pdf) / sizeof(*pdf); ++i) {
	const unsigned int n[2] = {i,10 - i};
	double k = 2;
	const double p[2] = {0.4,0.6};
	ensure(fabs(xll_ran_multinomial_pdf(k,p,n) - pdf[i]) < eps);
	//ensure(fabs(xll_cdf_multinomial_P(x, 1) - cdf[i]) < eps);
}

/*// http://www.wolframalpha.com/input/?i=Table%5BInverseCDF%5BNormalDistribution%5B0%2C1%5D%2C+p%5D%2C%7Bp%2C+.1%2C+.9%2C+.1%7D%5D
double inv[] = { -1.28155, -0.841621, -0.524401, -0.253347, 0, 0.253347, 0.524401, 0.841621, 1.28155 };
for (int i = 0; i < sizeof(inv) / sizeof(*inv); ++i) {
	double p = 0.1 + i*0.1;
	ensure(fabs(xll_cdf_multinomial_Pinv(p, 1) - inv[i]) < 2 * eps);
}*/

XLL_TEST_END(xll_ran_multinomial)